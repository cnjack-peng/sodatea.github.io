<!DOCTYPE html><html lang="zh-cmn-Hans"><head><meta charset="utf-8"><title>JavaScript 的设计失误 · 胖茶的在线笔记</title><meta name="X-UA-Compatible" content="IE=edge"><meta name="description" content="typeof null === &amp;#39;object&amp;#39;这是一个众所周知的失误。这个问题其实源于初版 JavaScript 实现中的一个 bug。

注：上述文章引用的代码其实已经不算是最初版本的实现了，但 Brendan Eich 自己也在 Twitter 上表示，这是一个 abstraction leak，可以理解为变相承认这是代码 bug。


&lt;h2 id=&quot;typeof-N"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="shortcut icon" href="/favicon.png"><link rel="canonical" href="https://sodatea.github.io/2016/07/14/javascript-design-regrets-and-gotchas/"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Kreon:400,700"><link rel="stylesheet" href="//at.alicdn.com/t/font_1451304868_2981977.css"><link rel="stylesheet" href="/styles/sleepless.css"><script>if (["sodatea.github.io"].indexOf(window.location.host) >= 0 && window.location.protocol !== 'https:') {
    window.location.protocol = 'https:';
}</script></head><body><header class="site-header"><div class="container"><nav class="nav-links"><a class="logo-link" href="/"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">blog</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://medium.com/@soda" target="_blank">en</a></li><li class="nav-list-item"><a class="nav-list-link" href="http://weibo.com/2451315930" target="_blank">weibo</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/sodatea" target="_blank">github</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">rss</a></li></ul></nav></div></header><main id="content"><div class="container"><div class="post"><article class="post-block"><header class="post-header"><h1 class="post-title"><a class="post-title-link" href="/2016/07/14/javascript-design-regrets-and-gotchas/">JavaScript 的设计失误</a></h1><span class="post-meta"><span class="post-time">2016-07-14</span></span></header><div class="post-content"><h2 id="typeof-null-39-object-39"><a href="#typeof-null-39-object-39" class="headerlink" title="typeof null === &#39;object&#39;"></a><code>typeof null === &#39;object&#39;</code></h2><p>这是一个众所周知的失误。这个问题其实源于<a href="http://www.2ality.com/2013/10/typeof-null.html" target="_blank" rel="external">初版 JavaScript 实现中的一个 bug</a>。</p>
<blockquote>
<p>注：上述文章引用的代码其实已经不算是最初版本的实现了，但 Brendan Eich 自己也在 Twitter 上表示，这是一个 <a href="https://twitter.com/BrendanEich/status/617450289889607681" target="_blank" rel="external">abstraction leak</a>，可以理解为变相承认这是代码 bug。</p>
</blockquote>
<a id="more"></a>
<h2 id="typeof-NaN-39-number-39"><a href="#typeof-NaN-39-number-39" class="headerlink" title="typeof NaN === &#39;number&#39;"></a><code>typeof NaN === &#39;number&#39;</code></h2><p>不太确定这个算不算一个设计失误，但毫无疑问这是反直觉的。</p>
<p>说到 NaN，其实还有更多有趣的知识点，这个 13 分钟的 talk 非常值得一看：<a href="https://github.com/lewisjellis/nantalk" target="_blank" rel="external">Idiosyncrasies of NaN</a>。</p>
<h2 id="NaN-isNaN-Number-isNaN"><a href="#NaN-isNaN-Number-isNaN" class="headerlink" title="NaN, isNaN(), Number.isNaN()"></a><code>NaN</code>, <code>isNaN()</code>, <code>Number.isNaN()</code></h2><p><code>NaN</code> 是 JavaScript 中唯一一个不等于自身的值。虽然这个设计其实理由很充分（参见前面推荐的那个 talk，在 IEE 754 规范中有非常多的二进制序列都可以被当做 <code>NaN</code>，所以任意计算出两个 <code>NaN</code>，它们在二进制表示上很可能不同），但不管怎样，这个还是非常值得吐槽……</p>
<p><code>isNaN()</code> 这个函数的命名和行为非常让人费解：</p>
<ol>
<li>它并不只是用来判断一个值是否为 <code>NaN</code>，因为所有对于所有非数值型的值它也返回 <code>true</code>；</li>
<li>但也不能说它是用来判断一个值是否为数值的，因为根据前文，<code>NaN</code> 的类型是 <code>number</code>，应当被认为是一个数值。</li>
</ol>
<p>还好，ES2015 引入了 <code>Number.isNaN()</code> 来拨乱反正：它只对参数为 <code>NaN</code> 的情况返回 <code>true</code>。</p>
<p>其他一些资料：</p>
<ul>
<li><a href="https://github.com/jquery-foundation/standards/blob/master/reports/TC39/2016-07.md#the-distinct-nan-values" target="_blank" rel="external">https://github.com/jquery-foundation/standards/blob/master/reports/TC39/2016-07.md#the-distinct-nan-values</a></li>
<li><a href="https://github.com/ljharb/get-nans" target="_blank" rel="external">https://github.com/ljharb/get-nans</a></li>
<li><a href="https://github.com/tc39/ecma262/issues/635" target="_blank" rel="external">https://github.com/tc39/ecma262/issues/635</a></li>
</ul>
<h2 id="分号自动插入（Automatic-Semicolon-insertion，ASI）机制"><a href="#分号自动插入（Automatic-Semicolon-insertion，ASI）机制" class="headerlink" title="分号自动插入（Automatic Semicolon insertion，ASI）机制"></a>分号自动插入（Automatic Semicolon insertion，ASI）机制</h2><h3 id="Restricted-Productions"><a href="#Restricted-Productions" class="headerlink" title="Restricted Productions"></a>Restricted Productions</h3><p>据 Brendan Eich 称，JavaScript 最初被设计出来时，<a href="https://brendaneich.com/2008/04/popularity/" target="_blank" rel="external">上级要求这个语言的语法必须像 Java</a>。所以，跟 Java 一样，JavaScript 的语句在解析时，是 <strong>需要分号</strong> 分隔的。但是后来出于降低学习成本，或者提高语言的容错性的考虑，他在语法解析中加入了分号自动插入的纠正机制。</p>
<p>这个做法的本意当然是好的，有不少其他语言也是这么处理的（比如 Swift）。但是问题在于，JavaScript 的语法设计得不够安全，导致 ASI 有不少特殊情况无法处理到，在某些情况下会错误地加上分号（在标准文档里这些被称为 <a href="https://tc39.github.io/ecma262/#sec-rules-of-automatic-semicolon-insertion" target="_blank" rel="external">Restricted Productions</a>）。<br>最典型的是 return 语句</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// returns undefined</div><div class="line"><span class="keyword">return</span></div><div class="line">&#123;</div><div class="line">    <span class="literal">status</span>: <span class="keyword">true</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">// <span class="keyword">returns</span> &#123; <span class="literal">status</span>: <span class="keyword">true</span> &#125;</div><div class="line"><span class="keyword">return</span> &#123;</div><div class="line">    <span class="literal">status</span>: <span class="keyword">true</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这导致了 JavaScript 社区写代码时花括号都不换行，这在其他编程语言社区是无法想象的。</p>
<h3 id="漏加分号的情况"><a href="#漏加分号的情况" class="headerlink" title="漏加分号的情况"></a>漏加分号的情况</h3><p>还有另外一种 ASI 不会纠正的问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="built_in">console</span>.log(x) &#125;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// do something</span></div><div class="line">&#125;)()</div></pre></td></tr></table></figure>
<p>这类问题通常出现在两个文件被压缩后再拼接到一起时。</p>
<h3 id="semicolon-less-风格"><a href="#semicolon-less-风格" class="headerlink" title="semicolon-less 风格"></a><a href="https://www.youtube.com/watch?v=gsfbh17Ax9I" target="_blank" rel="external">semicolon-less 风格</a></h3><p>Restricted Productions 的问题已经是语言的特性了并且无法绕开，无论如何我们都需要去学习掌握。</p>
<p>而前面提到的第二类问题，ASI 失灵的情况，采用强制分号的代码风格其实很难规避（现在有了 ESLint 的 <code>no-unexpected-multiline</code> 规则会后会容易点）。更好的办法是实践 semicolon-less 的代码风格，不在行末写分号，而是当行首出现 <code>+ - [ ( /</code> 这五个操作符之一时再往前加分号，这样的记忆成本和出错概率远低于强制分号风格。</p>
<h2 id="与-Object-is"><a href="#与-Object-is" class="headerlink" title="==, === 与 Object.is()"></a><code>==</code>, <code>===</code> 与 <code>Object.is()</code></h2><p>JavaScript 是一种弱类型语言，存在隐式类型转换。因此，<code>==</code> 的行为非常令人费解：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[] == ![]   <span class="comment">// true</span></div><div class="line"><span class="number">3</span> == <span class="string">'3'</span>    <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>所以各种 JavaScript 书籍都推荐使用 <code>===</code> 替代 <code>==</code> （仅在 null checking 之类的情况时可以除外）</p>
<p>但事实上，<code>===</code> 也并不总是靠谱，它<a href="http://www.2ality.com/2012/03/stricter-equality.html" target="_blank" rel="external">至少存在两类例外情况</a>：</p>
<ol>
<li>前文提到过， <code>NaN === NaN</code> 会返回 <code>false</code></li>
<li><code>+0 === -0</code> 会返回 <code>true</code>，然而这两个其实是不相等的值（<code>1 / +0 === Infinity; 1 / -0 === -Infinity</code>）</li>
</ol>
<p>一直到 ES2015，我们才有了一个可以比较两个值是否严格相等的方法：<code>Object.is()</code>，它对于 <code>===</code> 的这两种例外都做了正确的处理。</p>
<blockquote>
<p><a href="https://dorey.github.io/JavaScript-Equality-Table/" target="_blank" rel="external">关于 <code>==</code> 的坑，这里有份 JavaScript Equality Table 可以一看</a></p>
</blockquote>
<h2 id="Falsy-values"><a href="#Falsy-values" class="headerlink" title="Falsy values"></a>Falsy values</h2><p>JavaScript 中至少有六种假值（在条件表达式中与 <code>false</code> 等价）：<code>0</code>, <code>null</code>, <code>undefined</code>, <code>false</code>, <code>&#39;&#39;</code> 以及 <code>NaN</code>。</p>
<h2 id="、-操作符相关的隐式类型转换"><a href="#、-操作符相关的隐式类型转换" class="headerlink" title="+、- 操作符相关的隐式类型转换"></a><code>+</code>、<code>-</code> 操作符相关的隐式类型转换</h2><p>大致可以这样记：作为二元操作符的 <code>+</code> 会尽可能地把两边的值转为字符串，而 <code>-</code> 和作为一元操作符的 <code>+</code> 则会尽可能地把值转为数字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="string">"foo"</span> + + <span class="string">"bar"</span>) === <span class="string">"fooNaN"</span> <span class="comment">// true</span></div><div class="line"><span class="string">'3'</span> + <span class="number">1</span> <span class="comment">// '31'</span></div><div class="line"><span class="string">'3'</span> - <span class="number">1</span> <span class="comment">// 2</span></div><div class="line"><span class="string">'222'</span> - - <span class="string">'111'</span> <span class="comment">// 333</span></div></pre></td></tr></table></figure>
<h2 id="null、undefined-以及数组的-“holes”"><a href="#null、undefined-以及数组的-“holes”" class="headerlink" title="null、undefined 以及数组的 “holes”"></a><code>null</code>、<code>undefined</code> 以及数组的 “holes”</h2><p>在一个语言中同时有 <code>null</code> 和 <code>undefined</code> 两个表示空值的原生类型，乍看起来很难理解，不过这里有一些讨论可以一看：</p>
<ul>
<li><a href="https://twitter.com/BrendanEich/status/330775086208524288" target="_blank" rel="external">Java has null but only for reference types. With untyped JS, the uninitialized value should not be reference-y or convert to 0</a>.</li>
<li><a href="https://github.com/DavidBruant/ECMAScript-regrets/issues/26#issue-13943504" target="_blank" rel="external">GitHub 上的一些讨论</a></li>
<li><a href="https://twitter.com/BrendanEich/status/652442934151938048" target="_blank" rel="external">Null for Objects and undefined for primitives</a></li>
</ul>
<p>不过数组里的 “holes” 就非常难以理解了。</p>
<p>产生 holes 的方法有两种：一是定义数组字面量时写两个连续的逗号：<code>var a = [1, , 2]</code>；二是使用 <code>Array</code> 对象的构造器，<code>new Array(3)</code>。</p>
<p>数组的各种方法对于 holes 的处理非常非常非常不一致，有的会跳过（<code>forEach</code>），有的不处理但是保留（<code>map</code>），有的会消除掉 holes（<code>filter</code>），还有的会当成 undefined 来处理（<code>join</code>）。这可以说是 JavaScript 中最大的坑之一，不看文档很难自己理清楚。</p>
<p>具体可以参考这两篇文章：</p>
<ul>
<li><a href="http://www.2ality.com/2013/07/array-iteration-holes.html" target="_blank" rel="external">Array iteration and holes in JavaScript</a></li>
<li><a href="http://www.2ality.com/2015/09/holes-arrays-es6.html" target="_blank" rel="external">ECMAScript 6: holes in Arrays</a></li>
</ul>
<h2 id="Array-like-objects"><a href="#Array-like-objects" class="headerlink" title="Array-like objects"></a>Array-like objects</h2><p>JavaScript 中，类数组但不是数组的对象不少，这类对象往往有 <code>length</code> 属性、可以被遍历，但缺乏一些数组原型上的方法，用起来非常不便。比如在为了能让 <code>arguments</code> 对象用上 <code>shift</code> 方法，我们往往需要先写这样一条语句：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>)</div></pre></td></tr></table></figure>
<p>非常不便。</p>
<p>在 ES2015 中，<code>arguments</code> 对象不再被建议使用，我们可以用 rest parameter （<code>function f(...args) {}</code>）代替，这样拿到的对象就直接是数组了。</p>
<p>不过在语言标准之外，DOM 标准中也定义了不少 Array-like 的对象，比如 <code>NodeList</code> 和 <code>HTMLCollection</code>。<br>对于这些对象，在 ES2015 中我们可以用 spread operator 处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>)</div><div class="line"><span class="keyword">const</span> nodeArray = [...nodeList]</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(nodeList))   <span class="comment">// [object NodeList]</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(nodeArray))   <span class="comment">// [object Array]</span></div></pre></td></tr></table></figure>
<h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a><code>arguments</code></h2><p>在非严格模式（sloppy mode）下，对 arguments 赋值会改变对应的 <strong>形参</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(x === <span class="number">1</span>);</div><div class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">2</span>;</div><div class="line">    <span class="built_in">console</span>.log(x === <span class="number">2</span>);	<span class="comment">// true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">x</span>) </span>&#123;</div><div class="line"><span class="meta">    'use strict'</span>;</div><div class="line">    <span class="built_in">console</span>.log(x === <span class="number">1</span>);</div><div class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">2</span>;</div><div class="line">    <span class="built_in">console</span>.log(x === <span class="number">2</span>);	<span class="comment">// false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">a(<span class="number">1</span>);</div><div class="line">b(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<h2 id="函数级作用域-与-变量提升（Variable-hoisting）"><a href="#函数级作用域-与-变量提升（Variable-hoisting）" class="headerlink" title="函数级作用域 与 变量提升（Variable hoisting）"></a>函数级作用域 与 变量提升（Variable hoisting）</h2><h3 id="函数级作用域"><a href="#函数级作用域" class="headerlink" title="函数级作用域"></a>函数级作用域</h3><p>蝴蝶书上的例子想必大家都看过：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The closure in loop problem</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i !== <span class="number">10</span>; ++i) &#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(i) &#125;, <span class="number">0</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数级作用域本身没有问题，但是如果如果只能使用函数级作用域的话，在很多代码中它会显得非常 <strong>反直觉</strong>，比如上面这个循环的例子，对程序员来说，根据花括号的位置确定变量作用域远比找到外层函数容易得多。</p>
<p>在以前，要解决这个问题，我们只能使用闭包 + IIFE 产生一个新作用域，代码非常难看（其实 <code>with</code> 以及 <code>catch</code> 语句后面跟的代码块也算是块级作用域，但这并不通用）。</p>
<p>幸而现在 ES2015 引入了 <code>let</code> / <code>const</code>，让我们终于可以用上真正的块级作用域。</p>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>JavaScript 引擎在执行代码的时候，会先处理作用域内所有的变量声明，给变量分配空间（在标准里叫 binding），然后再执行代码。</p>
<p>这本来没什么问题，但是 <code>var</code> 声明在被分配空间的同时也会被初始化成 <code>undefined</code>（<a href="https://es5.github.io/#x10.2.1.1.2" target="_blank" rel="external">ES5 中的 CreateMutableBinding</a>），这就相当于把 <code>var</code> 声明的变量提升到了函数作用域的开头，也就是所谓的 “hoisting”。</p>
<p>ES2015 中引入的 <code>let</code> / <code>const</code> 则实现了 temporal dead zone，虽然进入作用域时用 <code>let</code> 和 <code>const</code> 声明的变量也会被分配空间，但不会被初始化。在初始化语句之前，如果出现对变量的引用，会报 <code>ReferenceError</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// without TDZ</span></div><div class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// undefined</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment">// with TDZ</span></div><div class="line"><span class="built_in">console</span>.log(b)  <span class="comment">// ReferenceError</span></div><div class="line"><span class="keyword">let</span> b = <span class="number">2</span></div></pre></td></tr></table></figure>
<p>在标准层面，这是通过把 CreateMutableBing 内部方法分拆成 CreateMutableBinding 和 InitializeBinding 两步实现的，只有 VarDeclaredNames 才会执行 InitializeBinding 方法。</p>
<h2 id="let-const"><a href="#let-const" class="headerlink" title="let / const"></a><code>let</code> / <code>const</code></h2><p>然而，<code>let</code> 和 <code>const</code> 的引入也带来了一个坑。主要是这两个关键词的命名不够精确合理。</p>
<p><code>const</code> 关键词所定义的是一个 <em>immutable binding</em>（类似于 Java 中的 <code>final</code> 关键词），而非真正的常量（ <em>constant</em> ），这一点对于很多人来说也是反直觉的。</p>
<p>ES2015 规范的主笔 Allen Wirfs-Brock 在 <a href="https://esdiscuss.org/topic/should-const-be-favored-over-let#content-6" target="_blank" rel="external">ESDiscuss 的一个帖子里</a> 表示，如果可以从头再来的话，他会更倾向于选择 <code>let var</code> / <code>let</code> 或者 <code>mut</code> / <code>let</code> 替代现在的这两个关键词，可惜这只能是一个美好的空想了。</p>
<h2 id="for-in"><a href="#for-in" class="headerlink" title="for...in"></a><code>for...in</code></h2><p><code>for...in</code> 的问题在于它会遍历到原型链上的属性，这个大家应该都知道的，使用时需要加上 <code>obj.hasOwnProperty(key)</code> 判断才安全。</p>
<p>在 ES2015+ 中，使用 <code>for (const key of Object.keys(obj))</code> 或者 <code>for (const [key, value] of Object.entries())</code> 可以绕开这个问题。</p>
<blockquote>
<p>顺便提一下 <code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>Reflect.ownKeys()</code> 的区别：我们最常用的一般是 <code>Object.keys()</code> 方法，<code>Object.getOwnPropertyNames()</code> 会把 <code>enumerable: false</code> 的属性名也加进来，而 <code>Reflect.ownKeys()</code> 在此基础上还会加上 <code>Symbol</code> 类型的键。</p>
</blockquote>
<h2 id="with"><a href="#with" class="headerlink" title="with"></a><code>with</code></h2><p>最主要的问题在于它依赖于运行时语义，影响优化。</p>
<p>此外还会降低程序可读性、易出错、易泄露全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">foo, length</span>) </span>&#123;</div><div class="line">  <span class="keyword">with</span> (foo) &#123;</div><div class="line">    <span class="built_in">console</span>.log(length)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">222</span>)   <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a><code>eval</code></h2><p><code>eval</code> 的问题不在于可以动态执行代码，这种能力无论如何也不能算是语言的缺陷。</p>
<h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><p>它的第一个坑在于传给 eval 作为参数的代码段能够接触到当前语句所在的闭包。</p>
<p>而用 <code>new Function</code> 动态执行的代码就不会有这个问题，因为 <code>new Function</code> 所生成的函数是确保执行在最外层作用域下的（<a href="http://perfectionkills.com/global-eval-what-are-the-options/#new_function" target="_blank" rel="external">严格来说标准里不是这样定义的，但实际效果基本可以看作等同，除了 <code>new Function</code> 中可以获取到 <code>arguments</code> 对象</a>）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">11</span></div><div class="line">    <span class="built_in">eval</span>(<span class="string">'(a = 22)'</span>)</div><div class="line">    <span class="built_in">console</span>.log(a)      <span class="comment">// 22</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">11</span></div><div class="line">    <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'return (a = 22)'</span>)()</div><div class="line">    <span class="built_in">console</span>.log(a)      <span class="comment">// 11</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="直接调用-vs-间接调用（Direct-Call-vs-Indirect-Call）"><a href="#直接调用-vs-间接调用（Direct-Call-vs-Indirect-Call）" class="headerlink" title="直接调用 vs 间接调用（Direct Call vs Indirect Call）"></a>直接调用 vs 间接调用（Direct Call vs Indirect Call）</h3><p>第二个坑是直接调用 <code>eval</code> 和间接调用的区别。</p>
<p>事实上，但是「直接调用」的概念就足以让人迷糊了。</p>
<p>首先，<a href="http://es5.github.io/#x15.1.2" target="_blank" rel="external"><code>eval</code> 是全局对象上的一个成员函数</a>；</p>
<p>但是，<a href="https://esdiscuss.org/topic/double-checking-if-window-eval-is-an-indirect-call-to-eval#content-1" target="_blank" rel="external"><code>window.eval()</code> 这样的调用 <strong>不算是</strong> 直接调用，因为这个调用的 base 是全局对象而不是一个 “environment record”</a>。</p>
<p>接下来的就是历史问题了。</p>
<ul>
<li>在 ES1 时代，<code>eval</code> 调用并没有直接和间接的区分；</li>
<li>然后在 ES2 中，加入了直接调用（direct call）的概念。根据 <a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/#indirect-eval-call" target="_blank" rel="external">Dmitry Soshnikov 后来的说法</a>，区分这两种调用可能是处于安全考虑。此时唯一合法的 <code>eval</code> 使用方式是 <strong>直接调用</strong>，如果 <code>eval</code> 被间接调用了或者被赋值给其他变量了，JavaScript 引擎 <strong>可以选择</strong> 报一个 Runtime Error（<a href="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%202nd%20edition,%20August%201998.pdf" target="_blank" rel="external">ECMA-262 2nd Edition</a>, p.63）。</li>
<li>但是浏览器厂商们在试图实现这个特性时，发现这会让一些旧网站不兼容。</li>
<li>考虑到这毕竟是可选的特性，他们最后就选择了不报错，转而让所有间接调用的 <code>eval</code> 都在全局作用域下执行。<br>这样一来，既保持了对旧网站的兼容性，也保证了一定程度的安全性。</li>
<li><a href="https://mail.mozilla.org/pipermail/es-discuss/2011-February/012852.html" target="_blank" rel="external">到了 ES5 时期，标准制定者们希望能够和当前约定俗成的实现保持一直并规范化，所以去掉了之前标准里的可选实现，转而规定了间接调用 <code>eval</code> 时的行为</a></li>
</ul>
<p>直接调用和间接调用最大的区别在于他们的作用域不同：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> x = <span class="number">2</span>, y = <span class="number">4</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">"x + y"</span>))    <span class="comment">// Direct call, uses local scope, result is 6</span></div><div class="line">  <span class="keyword">var</span> geval = <span class="built_in">eval</span>;</div><div class="line">  <span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">"x + y"</span>))   <span class="comment">// Indirect call, uses global scope, throws ReferenceError because `x` is undefined</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>间接调用 <code>eval</code> 最大的用处（可能也是唯一的实际用处）是在任意地方获取到全局对象（然而 Function(‘return this’)() 也能做到这一点）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 即使是在严格模式下也能起作用</span></div><div class="line"><span class="keyword">var</span> global = (<span class="string">"indirect"</span>, <span class="built_in">eval</span>)(<span class="string">"this"</span>);</div></pre></td></tr></table></figure></p>
<p>未来，如果 Jordan Harband 的 <a href="https://github.com/tc39/proposal-global" target="_blank" rel="external"><code>System.global</code> 提案</a>能进入到标准的话，这最后一点用处也用不到了……</p>
<h2 id="非严格模式下，赋值给未声明的变量会导致产生一个新的全局变量"><a href="#非严格模式下，赋值给未声明的变量会导致产生一个新的全局变量" class="headerlink" title="非严格模式下，赋值给未声明的变量会导致产生一个新的全局变量"></a>非严格模式下，赋值给未声明的变量会导致产生一个新的全局变量</h2><h2 id="Value-Properties-of-the-Global-Object"><a href="#Value-Properties-of-the-Global-Object" class="headerlink" title="Value Properties of the Global Object"></a>Value Properties of the Global Object</h2><p>我们平时用到的 <code>NaN</code>, <code>Infinity</code>, <code>undefined</code> 并不是作为 primitive value 被使用（而 <code>null</code> 是 primitive value），<a href="http://es5.github.io/#x15.1.1" target="_blank" rel="external">而是定义在全局对象上的属性名</a>。</p>
<p>在 ES5 之前，这几个属性甚至可以被覆盖，直到 ES5 之后它们才被改成 non-configurable、non-writable。</p>
<p>然而，因为这几个属性名都不是 JavaScript 的保留字，所以可以被用来当做变量名使用。即使全局变量上的这几个属性不可被更改，我们仍然可以在自己的作用域里面对这几个名字进行覆盖。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// logs "foo string"</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">var</span> <span class="literal">undefined</span> = <span class="string">'foo'</span>; <span class="built_in">console</span>.log(<span class="literal">undefined</span>, <span class="keyword">typeof</span> <span class="literal">undefined</span>); &#125;)();</div></pre></td></tr></table></figure>
<h2 id="Stateful-RegExps"><a href="#Stateful-RegExps" class="headerlink" title="Stateful RegExps"></a>Stateful RegExps</h2><p>JavaScript 中，正则对象上的函数是有状态的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> re = <span class="regexp">/foo/g</span></div><div class="line"><span class="built_in">console</span>.log(re.test(<span class="string">'foo bar'</span>)) <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(re.test(<span class="string">'foo bar'</span>)) <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>这使得这些方法难以调试、无法做到线程安全。</p>
<p>Brendan Eich 的说法是<a href="https://twitter.com/BrendanEich/status/231066800304046080" target="_blank" rel="external">这些方法来自于 90 年代的 Perl 4，那时候并没有想到这么多</a></p>
<h2 id="weird-syntax-of-import"><a href="#weird-syntax-of-import" class="headerlink" title="weird syntax of import"></a>weird syntax of <code>import</code></h2><p>现在的语法是 <code>import x from &#39;y&#39;</code>，但是改成 <code>from y import x</code> 的话，会更自然、更方便触发 IDE / 编辑器的自动补全。</p>
<p>Brendan Eich 也在 <a href="https://esdiscuss.org/topic/2-questions-about-es6-module-loaders#content-3" target="_blank" rel="external">ESDiscuss 的一篇帖子</a>中对此表达过后悔之情。</p>
<p>另外，尽管很多人认为 ES2015 的模块系统是借鉴了 python，但事实上，根据 ES2015 模块系统的设计者 <a href="http://calculist.org/blog/2012/06/29/static-module-resolution/" target="_blank" rel="external">Dave Herman 的说法</a>，这个模块系统的理念主要是参考了 <a href="https://racket-lang.org/" target="_blank" rel="external">Racket</a>，跟 python 半毛钱关系都没有（除了最后定下来的语法恰好有点相似）。</p>
<h2 id="Array-constructor-inconsistency"><a href="#Array-constructor-inconsistency" class="headerlink" title="Array constructor inconsistency"></a>Array constructor inconsistency</h2><p>这是 API 设计的失误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// &lt;https://github.com/DavidBruant/ECMAScript-regrets/issues/21&gt;</span></div><div class="line"><span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></div><div class="line"><span class="built_in">Array</span>(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [2, 3]</span></div><div class="line"><span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// [,,] WAT</span></div></pre></td></tr></table></figure>
<h2 id="Primitive-type-wrappers"><a href="#Primitive-type-wrappers" class="headerlink" title="Primitive type wrappers"></a>Primitive type wrappers</h2><p>JavaScript 中的 primitive type wrappers (Boolean / Number / String…）绝对是臭名昭著，各种合理或不合理的比较规则和类型转换能把人折腾疯，这里就不详述了（<del>其实是太懒了写不动了</del>。</p>
<p><a href="https://brendaneich.com/2005/11/js2-design-notes/" target="_blank" rel="external">Brendan Eich 在 JS2/ES4 中曾经试图用激进的强类型方案一劳永逸地解决掉这个问题</a>，不过后来 ES4 不了了之了，这个提案也就被搁置在一边了。</p>
<h2 id="Date-Object"><a href="#Date-Object" class="headerlink" title="Date Object"></a>Date Object</h2><p>JavaScript 里的 <code>Date</code> 对象是直接抄的 Java <code>Date</code> 类，所以这些问题其实都继承自 Java（其实不少方法在 Java 里都已经 deprecated 了，只是 JavaScript 演进了这么多年，一直没有加进 <code>Date</code> 的替代品）。</p>
<h3 id="Date-getMonth"><a href="#Date-getMonth" class="headerlink" title="Date.getMonth()"></a><code>Date.getMonth()</code></h3><p><code>Date.getMonth()</code> 的返回值是从 0 开始计的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2016-07-14'</span>)</div><div class="line">d.getDate()     <span class="comment">// 14</span></div><div class="line">d.getYear()     <span class="comment">// 116 (2016 - 1900)</span></div><div class="line">d.getMonth()    <span class="comment">// 6</span></div></pre></td></tr></table></figure>
<h3 id="Date-comparison"><a href="#Date-comparison" class="headerlink" title="Date comparison"></a><code>Date</code> comparison</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ node</div><div class="line">&gt; <span class="built_in">d1</span> = new Date(<span class="string">'2016-01-01'</span>)</div><div class="line"><span class="symbol">Fri</span> Jan <span class="number">01</span> <span class="number">2016</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span> GMT+<span class="number">0800</span> (CST)</div><div class="line">&gt; <span class="built_in">d2</span> = new Date(<span class="string">'2016-01-01'</span>)</div><div class="line"><span class="symbol">Fri</span> Jan <span class="number">01</span> <span class="number">2016</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span> GMT+<span class="number">0800</span> (CST)</div><div class="line">&gt; <span class="built_in">d1</span> &lt;= <span class="built_in">d2</span></div><div class="line"><span class="symbol">true</span></div><div class="line">&gt; <span class="built_in">d1</span> &gt;= <span class="built_in">d2</span></div><div class="line"><span class="symbol">true</span></div><div class="line">&gt; <span class="built_in">d1</span> == <span class="built_in">d2</span></div><div class="line"><span class="symbol">false</span></div><div class="line">&gt; <span class="built_in">d1</span> === <span class="built_in">d2</span></div><div class="line"><span class="symbol">false</span></div></pre></td></tr></table></figure>
<p>原因是抽象关系比较算法中，左右值在一定情况下会先 ToNumber，而抽象相等比较时则不会做转换，所以造成了这种情况。</p>
<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a><code>prototype</code></h2><p><code>prototype</code> 有两个槽点。</p>
<p>第一点是它的命名不合理。</p>
<blockquote>
<p>There are only two hard things in Computer Science: cache invalidation and naming things<br>– Phil Karlton</p>
</blockquote>
<p>JavaScript 中的各种词不达意的命名已经让人无力吐槽了……</p>
<p>作为对象属性的 <code>prototype</code>，其实根本就不是我们讨论原型继承机制时说的「原型」概念。<br><a href="http://johnkpaul.github.io/presentations/empirejs/javascript-bad-parts/#/11" target="_blank" rel="external"><code>fallbackOfObjectsCreatedWithNew</code> would be a better name.</a></p>
<p>而对象真正意义上的原型，在 ES5 引入 <code>Object.getPrototypeOf()</code> 方法之前，我们并没有常规的方法可以获取。</p>
<p>不过很多浏览器都实现了非标准的 <code>__proto__</code>（IE 除外），在 ES2015 中，这一扩展属性也得以标准化了。</p>
<h2 id="Object-destructuring-syntax"><a href="#Object-destructuring-syntax" class="headerlink" title="Object destructuring syntax"></a>Object destructuring syntax</h2><p>解构赋值时给变量起别名的语法有点让人费解：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// &lt;https://twitter.com/Louis_Remi/status/748816910683283456&gt;</span></div><div class="line"><span class="comment">// 这里解构出来的新变量是 y，它等价于 z.x</span></div><div class="line"><span class="comment">// 冒号可以读作 'as'，方便记忆</span></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">x</span>: y &#125; = z</div></pre></td></tr></table></figure>
<p>虽然这并不能算作是设计失误（毕竟很多其他语言也这么做），但毕竟不算直观。</p>
<h2 id="其他参考文献"><a href="#其他参考文献" class="headerlink" title="其他参考文献"></a>其他参考文献</h2><p><a href="https://esdiscuss.org/topic/10-biggest-js-pitfalls#content-5" target="_blank" rel="external">https://esdiscuss.org/topic/10-biggest-js-pitfalls#content-5</a><br><a href="https://esdiscuss.org/topic/excluding-features-from-sloppy-mode" target="_blank" rel="external">https://esdiscuss.org/topic/excluding-features-from-sloppy-mode</a><br><a href="http://wtfjs.com/" target="_blank" rel="external">http://wtfjs.com/</a><br><a href="http://bonsaiden.github.io/JavaScript-Garden/" target="_blank" rel="external">http://bonsaiden.github.io/JavaScript-Garden/</a><br><a href="https://www.nczonline.net/blog/2012/07/24/thoughts-on-ecmascript-6-and-new-syntax/" target="_blank" rel="external">https://www.nczonline.net/blog/2012/07/24/thoughts-on-ecmascript-6-and-new-syntax/</a></p>
</div></article></div></div></main><footer><div class="container"><div class="pagination"><a class="next" href="/2016/05/12/esnext-coding-style-guide/">ESNext 代码风格指南<i class="iconfont icon-cc-right"></i></a></div><div class="ds-thread" data-thread-key="2016/07/14/javascript-design-regrets-and-gotchas/" data-title="JavaScript 的设计失误" data-url="https://sodatea.github.io/2016/07/14/javascript-design-regrets-and-gotchas/" data-author-key="1"></div><script>var duoshuoQuery = {short_name:"sodatea"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'https://nzxbwjjh8.qnssl.com/duoshuo_embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create', 'UA-71940984-1', 'auto');
ga('send','pageview');
</script><script src="//cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>